- DPI CREATION 
sm2_m3.ps -> m3_dpi.cpp
File: marionette/rtl_puncher/punch_specs/sm2_m3.ps

This file has signals that create (I suposse with a script) DPI functions.
For example:
@begin punch_name:create_memop_inorder creates a create_memop_inorder_DPI function in m3_dpi.cpp (marionette/core_rtl/Sm2_a/rtl/m3_dpi.cpp)

Definition:
@begin 
punch_name: dpi_function_name
top_module: ?
clock: clock_signal
reset: reset_signal
dpi_group: ? -> file_name?
hierarchy: path_to_signal port_size: signal_size type: trigger ->calls the DPI function 
hierarchy: ... port_size: ... -> function arguments
@end

puncher: 
marionette/rtl_puncher/punch.py
creates file to call DPI functions


- Events registration and execution
m3_dpi.cpp -> boom_m3_t.cpp
File: marionette/models/m3/bridge/boom_m3_t.cpp

DPI functions register events, by calling boom_m3_t register_event() which are defined in boom_m3_t.cpp

boom_m3_t has a struct of type boom_m3_impl that contains a list of commands and pointer to dromajo_t (called core_model_ptr).

For each event, a command is pushed in the list. These are then executed by priority by the serve_registered_events() function, which calls the Execute() function of each type of commands (defined in marionette/models/m3/bridge/boom_m3_commands)



- RTL event types defined in: marionette/models/m3/bridge/rtl_event.h


Doubts:
- The only kind of event that receives the pointer to the core_model_ptr (in this case, dromajo_t) is kCommitMemop, why? The execution of this command calls the update_register() function of core_model_ptr.
- Stores will be checked by the M3. Loads will be checked against Spike ONLY when the operation has commited (after the update_register() function of kCommitMemop). So the core will always see the commited value of the loads, no intermediate state.


- Gold core? should we make Spike's processor extend from this?
- Relation between dromajo_t and Gold core?
Gold cores are used in bridges (bridge_boom, bridge_inorder, etc.) and tests. Are these gold cores our processor_t from spike?
- We should create a Spike model instead of dromajo in marionette/models


Events we need from RTL (transformed into m3::RTLEvent):
- Create memop inorder -> create_memop_inorder kCreateMemop @m3_dpi
- Add address to load/store queues -> add_store_address/add_load_address kAddMemopAddress @m3_dpi
- Perform load -> i_perform_load kPerformLoad @m3_dpi
- Add store data -> add_store_data kAddStoreData @m3_dpi
- Store completion -> complete_store kCompleteStore @m3_dpi
- Commit memop -> commit_memop kCommitMemop @m3_dpi
- Update cache metadata -> update_cache_meta kUpdateCacheLineState @m3_dpi
- Update cache data -> update_cache_data kUpdateCacheLineData @m3_dpi


RTL Events:
enum class RTLEvent
{
    kUndefined,
    kCreateMemop,
    kAddMemopAddress,
    kPerformLoad,
    kAddStoreData,
    kCompleteStore, -> what does store_succeed mean? check in RTL
    kCommitMemop, -> ROB commits memop
    kUpdateCacheLineState,
    kUpdateCacheLineData
};

Events we need to connect with Dromajo/Spike?
- Register instruction at dispatch (memop only?) -> register_instruction_DPI @dromajo_dpi.cpp
- Writeback to integer register file -> write_back_data @dromajo_dpi
- Writeback to fp register file -> write_back_fpdata @dromajo_dpi
- Writeback to vector register?
- ROB commit instruction -> rob_commit @dromajo_dpi


RTL event:
- Value written by the core is locally visible, then trigger DPI call, to update M3. 
- Priority of events to be executed at the end of the clock cycle.